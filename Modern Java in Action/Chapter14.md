# Chap14. 자바 모듈 시스템

## 14.1 압력: 소프트웨어 유추

### 관심사분리

- **컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙**
- 다양한 형식으로 구성된 지출을 파싱, 결과를 고객에게 요약 보고하는 app 개발 가정
    - Soc를 적용함으로 파싱, 분석,  레포트 기능을 모듈이라는 각각의 부분 즉, 서로 거의 겹치지 않는 코드 그룹으로 분리
        
        → 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적 표현
        
    - SoC 원칙은 모델, 뷰, 컨트롤러 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 상황에 유용
        - SoC 원칙의 장점
            1. 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업
            2. 개별 부분 재사용하기 쉬움
            3. 전체 시스템을 쉽게 유지보수 가능

### 정보 은닉

- **세부 구현을 숨기도록 장려하는 원칙**
    - 세부 구현을 숨김으로써 프로그램의 어떤 부분을 바꾸었을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있음
- **캡슐화: 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미**
    - 코드의 내부적인 변화가 의도치 않게 외부에 영향을 미칠 가능성을 줄여줌
- 자바 9 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러로 확인할 방법이 없었음

### 자바 소프트웨어

- 잘 설계된 소프트웨어는 다음과 같은 위와 같은 두 가지 원칙을 따르는 것이 필수

## 14.2 자바 모듈 시스템을 설계한 이유

### 모듈화의 한계

자바는 클래스, 패키지, JAR 세 가지 수준의 코드 그룹화 제공, 클래스와 관련해 자바는 접근 제한자와 캡슐화 지원했지만 패키지와 JAR 수준에서는 캡슐화를 거의 지원하지 않았음

- **제한된 가시성 제어**
    - 자바는 정보를 감출 수 있는 접근자 제공
        - public, protected, defualt, private 네 가지 가시성 접근자
    - 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public으로 이들을 선언해야 함
        - 결과적으로 이들 클래스와 인터페이스는 모두에게 공개
        - 특히 기본 구현을 제공하는 의미로 “impl” 이라는 문자열을 가진 패키지에서 이런 문제가 두드러짐
    - 보안 측면에서 볼 때 코드가 노출되었으므로 코드를 임의로 조작하는 위협에 더 많이 노출
- **클래스 경로**
    1. 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없음
        - 예로 파싱 라이브러리의 JSONParser 클래스를 지정할 때 버전 1.0인지 2.0인지 지정할 수 가 없음
    2. 클래스 경로는 명시적인 의존성을 지원하지 않음
        - 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않음

## 14.3 자바 모듈: 큰 그림

자바 8은 **모듈**이라는 새로운 자바 프로그램 구조 단위를 제공

- **모듈 디스크립터**는 [module-info.java](http://module-info.java) 라는 특별한 파일에 저장
- 모듈 디스크립터는 보통  패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화 할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출

## 14.4 자바 모듈 시스템으로 애플리케이션 개발하기

1. 애플리케이션 셋업
    - 프로젝트 준비(요구사항 정의)
        - 파일이나 URL에서 비용 목록을 읽는다.
        - 비용의 문자열 표현을 파싱한다.
        - 통계를 계산한다.
        - 유용한 요약 정보를 표시한다.
        - 각 태스크의 시작, 마무리 지점을 제공한다.
2. 세부적인 모듈화와 거친 모듈화
    - 세부적인 모듈화 기법
        - 모든 패키지가 자신의 모듈을 갖음
            - 이득에 비해 설계 비용이 증가
    - 거친 모듈화 기법
        - 대부분은 한 모듈이 시스템의 모든 패키지를 포함
            - 모듈화의 모든 장점을 잃음
3. 자바 모듈 시스템 기초
    - 모듈 디스크립터로 모듈의 소스 코드 파일 루트에 위치해야 하며 모듈의 의존성 그리고 어떤 기능을 외부로 노출할지 정의

## 14.5 여러 모듈 활용하기

1. exports 구문
    - 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만듦
    - 모듈 내의 모든 것이 캡슐화
2. requires 구문
    - 의존하고 있는 모듈 지정
    - 기본적으로 모든 모듈은 java.base 라는 플랫픔 모듈에 의존

## 14.6 컴파일과 패키징

프로젝트를 설정하고 모듈을 정의하였으니 메이븐 등의 빌드 도구를 이용해 프로젝트 컴파일

- 각 모듈에  pom.xml 추가
- 총 3개의 pom.xml 파일을 추가해 메이븐 디렉터리 구조 완성
    1. pom.xml
        
        1.1 expenses.application
        
        pom.xml
        
        1.2 expenses.readers
        
        pom.xml
        

## 14.7 자동 모듈

HttpReader를 저수준으로 구현하지 않고 아파치 프로젝트의 httpClient 같은 특화 라이브러리를 사용해 구현한다고 가정

- httpClient 는 자바 모듈이 아니지만 자바는 JAR를 자동 모듈이라는 형태로 적절하게 변환
- module-info 파일을 가지지 않은 모든 JAR는 자동 모듈이 됨

## 14.8 모듈 정의와 구문들

```java
module com.iteratrlearning.application{

}
```

module 지시어를 이용해 모듈을 정의할 수 있음

- requires: `requires com.iteratrlearning.ui;`
- exports: `exports  com.iteratrlearning.ui;`
- requires transitive: `requires transitive com.iteratrlearning.ui;`
- exports to: `com.iteratrlearning.ui.widgets to com.iteratrlearning.ui.widgetuser;`
- open과 opens: 위 예제 코드 module 앞에 `open` 키워드 추가
